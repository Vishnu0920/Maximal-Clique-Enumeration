<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Source Code</title>
    <link rel="stylesheet" href="assets/css/style.css">
    <style>
        /* Additional styles for code viewer */
        .code-viewer {
            margin: 20px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .tabs {
            display: flex;
            background: #f5f5f5;
            border-bottom: 1px solid #ddd;
        }
        
        .tab-btn {
            padding: 12px 20px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        
        .tab-btn.active {
            background: #0077cc;
            color: white;
        }
        
        .tab-content {
            display: none;
            padding: 15px;
            max-height: 500px;
            overflow-y: auto;
            background: white;
        }
        
        .tab-content.active {
            display: block;
        }
        
        pre {
            margin: 0;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <nav>
        <a href="index.html">Home</a>
        <a href="algorithms.html">Algorithms</a>
        <a href="datasets.html">Datasets</a>
        <a href="results.html">Results</a>
        <a href="code.html">Source Code</a>
        <a href="report.html">Report</a>
    </nav>
    <header>
        <h1>Source Code</h1>
    </header>
    <section>
        <h2>GitHub Repository</h2>
        <a href="https://github.com/<username>/maximal-clique-enumeration" target="_blank" class="github-btn">
            View on GitHub
        </a>
    </section>

    <section>
        <h2>Algorithm Implementations</h2>
        <div class="code-viewer">
            <div class="tabs">
                <button class="tab-btn active" onclick="openTab(event, 'tab1')">Tomita (Maximal Clique)</button>
                <button class="tab-btn" onclick="openTab(event, 'tab2')">Bron-Kerbosch with Degeneracy</button>
                <button class="tab-btn" onclick="openTab(event, 'tab3')">Chiba Arboricity</button>
            </div>
            
            <div id="tab1" class="tab-content active">
                <pre><code>// CLIQUE Algorithm Implementation
function clique(R, P, X) {
    if (P.size === 0 && X.size === 0) {
        reportClique(R);
        return;
    }
    
    for (const v of P) {
        const neighbors = getNeighbors(v);
        clique(new Set([...R, v]), 
               intersection(P, neighbors),
               intersection(X, neighbors));
        P.delete(v);
        X.add(v);
    }
}</code></pre>
            </div>
            
            <div id="tab2" class="tab-content">
                <pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;chrono&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;

using namespace std;

long long clique_counter;

vector<int> compute_degeneracy_ordering(const unordered_map<int, unordered_set<int>>& adj_list) {
    unordered_map<int, unordered_set<int>> adj = adj_list;
    unordered_map<int, int> degree;
    int max_degree = 0;

    for (const auto& [vertex, neighbors] : adj) {
        degree[vertex] = neighbors.size();
        max_degree = max(max_degree, degree[vertex]);
    }

    vector<vector<int>> D(max_degree + 1);
    for (const auto& [vertex, deg] : degree) {
        D[deg].push_back(vertex);
    }

    vector<int> ordering;
    for (int i = 0; i < adj.size(); i++) {
        int d = 0;
        while (d <= max_degree && D[d].empty()) d++;

        int v = D[d].back();
        D[d].pop_back();
        ordering.push_back(v);

        for (int u : adj[v]) {
            if (adj[u].count(v)) {
                adj[u].erase(v);
                int old_deg = degree[u];
                int new_deg = old_deg - 1;
                degree[u] = new_deg;
                auto& old_list = D[old_deg];
                old_list.erase(remove(old_list.begin(), old_list.end(), u), old_list.end());
                D[new_deg].push_back(u);
            }
        }
        adj.erase(v);
    }
    return ordering;
}

void bron_kerbosch_pivot(vector<int>& R, vector<int>& P, vector<int>& X, 
    const unordered_map<int, unordered_set<int>>& adj_list, vector<vector<int>>& maximal_cliques, map<int, int>& clique_size_counts) {

    if (P.empty() && X.empty()) {
        maximal_cliques.push_back(R);
        clique_size_counts[R.size()]++;
        clique_counter++;
        return;
    }

    int pivot = -1;
    int max_neighbors = -1;
    
    vector<int> P_union_X = P;
    P_union_X.insert(P_union_X.end(), X.begin(), X.end());

    for (int u : P_union_X) {
        int count = 0;
        for (int v : P) {
            if (adj_list.at(u).count(v)) count++;
        }
        if (count > max_neighbors) {
            max_neighbors = count;
            pivot = u;
        }
    } 

    vector<int> P_copy = P; 

    for (auto it = P_copy.begin(); it != P_copy.end(); ) {
        int v = *it;
        if (adj_list.at(pivot).count(v)) {
            ++it;
            continue;
        }

        R.push_back(v);

        vector<int> new_P, new_X;
        for (int u : P) {
            if (adj_list.at(v).count(u)) {
                new_P.push_back(u);
            }
        }
        for (int u : X) {
            if (adj_list.at(v).count(u)) {
                new_X.push_back(u);
            }
        }

        bron_kerbosch_pivot(R, new_P, new_X, adj_list, maximal_cliques, clique_size_counts);
        
        R.pop_back();
        P.erase(remove(P.begin(), P.end(), v), P.end());
        X.push_back(v);
        
        it = P_copy.erase(it); 
    }
}

// Test Code
void test_bron_kerbosch() {
    unordered_map<int, unordered_set<int>> adj_list = {
        {1, {2, 3}},
        {2, {1, 3, 4}},
        {3, {1, 2, 4}},
        {4, {2, 3}}
    };

    vector<int> R, P, X;
    for (const auto& [vertex, _] : adj_list) {
        P.push_back(vertex);
    }

    vector<vector<int>> maximal_cliques;
    map<int, int> clique_size_counts;

    bron_kerbosch_pivot(R, P, X, adj_list, maximal_cliques, clique_size_counts);

    cout << "Maximal Cliques:" << endl;
    for (const auto& clique : maximal_cliques) {
        for (int v : clique) {
            cout << v << " ";
        }
        cout << endl;
    }

    cout << "Clique Size Counts:" << endl;
    for (const auto& [size, count] : clique_size_counts) {
        cout << "Size " << size << ": " << count << endl;
    }
}

int main() {
    test_bron_kerbosch();
    return 0;
}</code></pre>
            </div>

            <div id="tab3" class="tab-content">
                <pre><code>// Arboricity-based Implementation
function arboricityClique(graph) {
    const arboricity = calculateArboricity(graph);
    const cliques = [];
    
    for (const edge of graph.edges) {
        const [u, v] = edge;
        const commonNeighbors = intersection(
            graph.neighbors(u),
            graph.neighbors(v)
        );
        // Expand common neighbors to maximal cliques
        // using arboricity-based pruning
    }
    return cliques;
}</code></pre>
            </div>
        </div>
    </section>

    <script>
        function openTab(evt, tabName) {
            const tabContents = document.getElementsByClassName("tab-content");
            for (const tab of tabContents) {
                tab.classList.remove("active");
            }
            
            const tabBtns = document.getElementsByClassName("tab-btn");
            for (const btn of tabBtns) {
                btn.classList.remove("active");
            }
            
            document.getElementById(tabName).classList.add("active");
            evt.currentTarget.classList.add("active");
        }
    </script>
</body>
</html>